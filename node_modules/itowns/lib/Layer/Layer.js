"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageryLayers = exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var THREE = _interopRequireWildcard(require("three"));

var _LayerUpdateStrategy = require("./LayerUpdateStrategy");

var _InfoLayer = _interopRequireDefault(require("./InfoLayer"));

/**
 * @property {boolean} isLayer - Used to checkout whether this layer is a Layer.
 * Default is true. You should not change this, as it is used internally for
 * optimisation.
 */
var Layer =
/*#__PURE__*/
function (_THREE$EventDispatche) {
  (0, _inherits2["default"])(Layer, _THREE$EventDispatche);

  /**
   * Don't use directly constructor to instance a new Layer. Instead, use
   * another available type of Layer, implement a new one inheriting from this
   * one or use {@link View#addLayer}.
   *
   * @constructor
   * @protected
   *
   * @param {string} id - The id of the layer, that should be unique. It is
   * not mandatory, but an error will be emitted if this layer is added a
   * {@link View} that already has a layer going by that id.
   * @param {Object} [config] - Optional configuration, all elements in it
   * will be merged as is in the layer. For example, if the configuration
   * contains three elements `name, protocol, extent`, these elements will be
   * available using `layer.name` or something else depending on the property
   * name.
   *
   * @example
   * // Add and create a new Layer
   * const newLayer = new Layer('id', options);
   * view.addLayer(newLayer);
   *
   * // Change layer's visibility
   * const layerToChange = view.getLayerById('idLayerToChange');
   * layerToChange.visible = false;
   * view.notifyChange(); // update viewer
   *
   * // Change layer's opacity
   * const layerToChange = view.getLayerById('idLayerToChange');
   * layerToChange.opacity = 0.5;
   * view.notifyChange(); // update viewer
   *
   * // Listen properties
   * const layerToListen = view.getLayerById('idLayerToListen');
   * layerToListen.addEventListener('visible-property-changed', (event) => console.log(event));
   * layerToListen.addEventListener('opacity-property-changed', (event) => console.log(event));
   */
  function Layer(id) {
    var _this;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Layer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Layer).call(this));
    _this.isLayer = true;
    Object.assign((0, _assertThisInitialized2["default"])(_this), config);
    Object.defineProperty((0, _assertThisInitialized2["default"])(_this), 'id', {
      value: id,
      writable: false
    }); // Default properties

    _this.options = config.options || {};

    if (!_this.updateStrategy) {
      _this.updateStrategy = {
        type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC,
        options: {}
      };
    }

    _this.defineLayerProperty('frozen', false);

    _this.info = new _InfoLayer["default"]((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }
  /**
   * Defines a property for this layer, with a default value and a callback
   * executed when the property changes.
   * <br><br>
   * When changing the property, it also emits an event, named following this
   * convention: `${propertyName}-property-changed`, with `${propertyName}`
   * being replaced by the name of the property.  For example, if the added
   * property name is `frozen`, it will emit a `frozen-property-changed`.
   * <br><br>
   * @example <caption>The emitted event has some properties assigned to it</caption>
   * event = {
   *     new: {
   *         ${propertyName}: * // the new value of the property
   *     },
   *     previous: {
   *         ${propertyName}: * // the previous value of the property
   *     },
   *     target: Layer // the layer it has been dispatched from
   *     type: string // the name of the emitted event
   * }
   *
   * @param {string} propertyName - The name of the property, also used in
   * the emitted event name.
   * @param {*} defaultValue - The default set value.
   * @param {function} [onChange] - The function executed when the property is
   * changed. Parameters are the layer the property is defined on, and the
   * name of the property.
   */


  (0, _createClass2["default"])(Layer, [{
    key: "defineLayerProperty",
    value: function defineLayerProperty(propertyName, defaultValue, onChange) {
      var _this2 = this;

      var existing = Object.getOwnPropertyDescriptor(this, propertyName);

      if (!existing || !existing.set) {
        var property = this[propertyName] == undefined ? defaultValue : this[propertyName];
        Object.defineProperty(this, propertyName, {
          get: function get() {
            return property;
          },
          set: function set(newValue) {
            if (property !== newValue) {
              var event = {
                type: "".concat(propertyName, "-property-changed"),
                previous: {},
                "new": {}
              };
              event.previous[propertyName] = property;
              event["new"][propertyName] = newValue;
              property = newValue;

              if (onChange) {
                onChange(_this2, propertyName);
              }

              _this2.dispatchEvent(event);
            }
          }
        });
      }
    } // Placeholder
    // eslint-disable-next-line

  }, {
    key: "convert",
    value: function convert(data) {
      return data;
    }
    /**
     * Remove and dispose all objects from layer.
     */
    // eslint-disable-next-line

  }, {
    key: "delete",
    value: function _delete() {
      console.warn('Function delete doesn\'t exist for this layer');
    }
  }]);
  return Layer;
}(THREE.EventDispatcher);

var _default = Layer;
exports["default"] = _default;
var ImageryLayers = {
  // move this to new index
  // After the modification :
  //      * the minimum sequence will always be 0
  //      * the maximum sequence will always be layers.lenght - 1
  // the ordering of all layers (Except that specified) doesn't change
  moveLayerToIndex: function (layer, newIndex, imageryLayers) {
    newIndex = Math.min(newIndex, imageryLayers.length - 1);
    newIndex = Math.max(newIndex, 0);
    var oldIndex = layer.sequence;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = imageryLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var imagery = _step.value;

        if (imagery.id === layer.id) {
          // change index of specified layer
          imagery.sequence = newIndex;
        } else if (imagery.sequence > oldIndex && imagery.sequence <= newIndex) {
          // down all layers between the old index and new index (to compensate the deletion of the old index)
          imagery.sequence--;
        } else if (imagery.sequence >= newIndex && imagery.sequence < oldIndex) {
          // up all layers between the new index and old index (to compensate the insertion of the new index)
          imagery.sequence++;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  },
  moveLayerDown: function (layer, imageryLayers) {
    if (layer.sequence > 0) {
      this.moveLayerToIndex(layer, layer.sequence - 1, imageryLayers);
    }
  },
  moveLayerUp: function (layer, imageryLayers) {
    var m = imageryLayers.length - 1;

    if (layer.sequence < m) {
      this.moveLayerToIndex(layer, layer.sequence + 1, imageryLayers);
    }
  },
  getColorLayersIdOrderedBySequence: function (imageryLayers) {
    var copy = Array.from(imageryLayers);
    copy.sort(function (a, b) {
      return a.sequence - b.sequence;
    });
    return copy.map(function (l) {
      return l.id;
    });
  }
};
exports.ImageryLayers = ImageryLayers;