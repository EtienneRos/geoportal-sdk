"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _Layer2 = _interopRequireDefault(require("./Layer"));

var _LayeredMaterialNodeProcessing = require("../Process/LayeredMaterialNodeProcessing");

var _textureConverter = _interopRequireDefault(require("../Converter/textureConverter"));

var _Style = _interopRequireDefault(require("../Core/Style"));

/**
 * Fires when the visiblity of the layer has changed.
 * @event ColorLayer#visible-property-changed
 */

/**
 * Fires when the opacity of the layer has changed.
 * @event ColorLayer#opacity-property-changed
 */

/**
 * Fires when the sequence of the layer has changed, meaning that the order of
 * the layer changed in the view it is attached to.
 * @event ColorLayer#sequence-property-changed
 */

/**
 * @property {boolean} isColorLayer - Used to checkout whether this layer is a
 * ColorLayer. Default is true. You should not change this, as it is used
 * internally for optimisation.
 */
var ColorLayer =
/*#__PURE__*/
function (_Layer) {
  (0, _inherits2["default"])(ColorLayer, _Layer);

  /**
   * A simple layer, usually managing a texture to display on a view. For example,
   * it can be an aerial view of the ground or a simple transparent layer with the
   * roads displayed.
   *
   * @constructor
   * @extends Layer
   *
   * @param {string} id - The id of the layer, that should be unique. It is
   * not mandatory, but an error will be emitted if this layer is added a
   * {@link View} that already has a layer going by that id.
   * @param {Object} [config] - Optional configuration, all elements in it
   * will be merged as is in the layer. For example, if the configuration
   * contains three elements `name, protocol, extent`, these elements will be
   * available using `layer.name` or something else depending on the property
   * name.
   * @param {Source} [config.source] - Description and options of the source.
   *
   * @example
   * // Create a ColorLayer
   * const color = new ColorLayer('roads', {
   *     source: {
   *          protocol: 'wmts',
   *          url: 'http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL',
   *          format: 'image/png',
   *     }
   *     transparent: true
   * });
   *
   * // Add the layer
   * view.addLayer(color);
   */
  function ColorLayer(id) {
    var _this;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, ColorLayer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ColorLayer).call(this, id, config));
    _this.isColorLayer = true;
    _this.style = config.style ? new _Style["default"](config.style) : {};

    _this.defineLayerProperty('visible', true);

    _this.defineLayerProperty('opacity', 1.0);

    _this.defineLayerProperty('sequence', 0);

    _this.transparent = config.transparent || _this.opacity < 1.0;
    _this.noTextureParentOutsideLimit = config.source ? config.source.isFileSource : false;
    return _this;
  }

  (0, _createClass2["default"])(ColorLayer, [{
    key: "update",
    value: function update(context, layer, node, parent) {
      return (0, _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery)(context, this, node, parent);
    }
  }, {
    key: "convert",
    value: function convert(data, extentDestination) {
      return _textureConverter["default"].convert(data, extentDestination, this);
    }
    /**
    * All layer's textures are removed from scene and disposed from video device.
    */

  }, {
    key: "delete",
    value: function _delete() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.parent.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var root = _step.value;
          root.traverse((0, _LayeredMaterialNodeProcessing.removeLayeredMaterialNodeLayer)(this.id));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ColorLayer;
}(_Layer2["default"]);

var _default = ColorLayer;
exports["default"] = _default;