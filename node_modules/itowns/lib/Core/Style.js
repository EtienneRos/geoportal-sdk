"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Feature = require("./Feature");

var inv255 = 1 / 255;

function rgba2rgb(orig) {
  var result = orig.match(/(?:((hsl|rgb)a? *\(([\d.%]+(?:deg|g?rad|turn)?)[ ,]*([\d.%]+)[ ,]*([\d.%]+)[ ,/]*([\d.%]*)\))|(#((?:[\d\w]{3}){1,2})([\d\w]{1,2})?))/i);

  if (!result) {
    return {
      color: orig,
      opacity: 1.0
    };
  } else if (result[7]) {
    var opacity = 1.0;

    if (result[9]) {
      opacity = parseInt(result[9].length == 1 ? "".concat(result[9]).concat(result[9]) : result[9], 16) * inv255;
    }

    return {
      color: "#".concat(result[8]),
      opacity: opacity
    };
  } else if (result[0]) {
    return {
      color: "".concat(result[2], "(").concat(result[3], ",").concat(result[4], ",").concat(result[5], ")"),
      opacity: Number(result[6]) || 1.0
    };
  }
}
/**
 * Style defines {@link Feature} style.
 * @property {object} fill fill style.
 * @property {string} fill.color fill color string css.
 * @property {Image|Canvas} fill.pattern fill with pattern image.
 * @property {number} fill.opacity fill opacity.
 * @property {object} stroke stroke style.
 * @property {string} stroke.color stroke color string css.
 * @property {number} stroke.opacity stroke opacity.
 * @property {number} stroke.width stroke line width.
 * @property {object} point point style.
 * @property {string} point.color point color string css.
 * @property {string} point.line point line color string css.
 * @property {number} point.width point line width.
 * @property {number} point.opacity point opacity.
 * @property {number} point.radius point line radius
 */


var Style =
/*#__PURE__*/
function () {
  /**
   * Constructs the object.
   * @param  {Object}  [params={}] An object that can contain all properties of a Style.
   * @constructor
   */
  function Style() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, Style);
    this.isStyle = true;
    params.fill = params.fill || {};
    params.stroke = params.stroke || {};
    params.point = params.point || {};
    this.fill = {
      color: params.fill.color,
      opacity: params.fill.opacity,
      pattern: params.fill.pattern
    };
    this.stroke = {
      color: params.stroke.color,
      opacity: params.stroke.opacity,
      width: params.stroke.width
    };
    this.point = {
      color: params.point.color,
      line: params.point.line,
      opacity: params.point.opacity,
      radius: params.point.radius,
      width: params.point.width
    };
  }
  /**
   * set Style from geojson properties.
   * @param {object} properties geojson properties.
   * @param {number} type
   * @returns {Style}
   */


  (0, _createClass2["default"])(Style, [{
    key: "setFromGeojsonProperties",
    value: function setFromGeojsonProperties(properties, type) {
      if (type === _Feature.FEATURE_TYPES.POINT) {
        this.point.color = properties.fill || 'white';
        this.point.opacity = properties['fill-opacity'] || 1.0;
        this.point.line = properties.stroke || 'gray';
        this.point.radius = properties.radius || 2.0;
      } else {
        this.stroke.color = properties.stroke;
        this.stroke.width = properties['stroke-width'];
        this.stroke.opacity = properties['stroke-opacity'];

        if (type !== _Feature.FEATURE_TYPES.LINE) {
          this.fill.color = properties.fill;
          this.fill.opacity = properties['fill-opacity'] || 1.0;
        }
      }

      return this;
    }
    /**
     * set Style from vector tile layer properties.
     * @param {object} layer vector tile layer.
     * @returns {Style}
     */

  }, {
    key: "setFromVectorTileLayer",
    value: function setFromVectorTileLayer(layer) {
      if (layer.type === 'fill' && !this.fill.color) {
        var _rgba2rgb = rgba2rgb(layer.paint['fill-color']),
            color = _rgba2rgb.color,
            opacity = _rgba2rgb.opacity;

        this.fill.color = color;
        this.fill.opacity = layer.paint['fill-opacity'] || opacity || 1.0;
      }

      if (layer.type === 'line' && !this.stroke.color) {
        var _rgba2rgb2 = rgba2rgb(layer.paint['line-color']),
            _color = _rgba2rgb2.color,
            _opacity = _rgba2rgb2.opacity;

        this.stroke.color = _color;

        if ('line-width' in layer.paint) {
          this.stroke.width = layer.paint['line-width'].base || 3.0;
        }

        this.stroke.opacity = layer.paint['line-opacity'] || _opacity || 1.0;
      }

      if (layer.type === 'symbol') {
        var _rgba2rgb3 = rgba2rgb(layer.paint['text-color']),
            _color2 = _rgba2rgb3.color,
            _opacity2 = _rgba2rgb3.opacity;

        this.point.color = _color2;
        this.point.opacity = _opacity2;
        this.point.radius = 1.5;
      } else if (layer.type === 'circle') {
        var _rgba2rgb4 = rgba2rgb(layer.paint['circle-color']),
            _color3 = _rgba2rgb4.color,
            _opacity3 = _rgba2rgb4.opacity;

        this.point.color = _color3;
        this.point.opacity = _opacity3;
        this.point.radius = layer.paint['circle-radius'];
      }

      return this;
    }
  }]);
  return Style;
}();

var _default = Style;
exports["default"] = _default;