"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = newTileGeometry;

var THREE = _interopRequireWildcard(require("three"));

var _TileGeometry = _interopRequireDefault(require("../TileGeometry"));

var _Cache = _interopRequireDefault(require("../Scheduler/Cache"));

var _computeBufferTileGeometry = _interopRequireDefault(require("./computeBufferTileGeometry"));

var cacheBuffer = new Map();

function newTileGeometry(builder, params) {
  var _builder$computeShara = builder.computeSharableExtent(params.extent),
      sharableExtent = _builder$computeShara.sharableExtent,
      quaternion = _builder$computeShara.quaternion,
      position = _builder$computeShara.position;

  var south = sharableExtent.south.toFixed(6);
  var bufferKey = "".concat(builder.projection, "_").concat(params.disableSkirt ? 0 : 1, "_").concat(params.segment);
  var geometryKey = "".concat(bufferKey, "_").concat(params.level, "_").concat(south);

  var promiseGeometry = _Cache["default"].get(geometryKey); // build geometry if doesn't exist


  if (!promiseGeometry) {
    var resolve;
    promiseGeometry = new Promise(function (r) {
      resolve = r;
    });

    _Cache["default"].set(geometryKey, promiseGeometry);

    params.extent = sharableExtent;
    params.center = builder.center(params.extent).clone(); // Read previously cached values (index and uv.wgs84 only depend on the # of triangles)

    var cachedBuffers = cacheBuffer.get(bufferKey);
    params.buildIndexAndUv_0 = !cachedBuffers;
    params.builder = builder;
    return Promise.resolve((0, _computeBufferTileGeometry["default"])(params)).then(function (buffers) {
      if (!cachedBuffers) {
        cachedBuffers = {};
        cachedBuffers.index = new THREE.BufferAttribute(buffers.index, 1);
        cachedBuffers.uv = new THREE.BufferAttribute(buffers.uvs[0], 2); // Update cacheBuffer

        cacheBuffer.set(bufferKey, cachedBuffers);
      }

      buffers.index = cachedBuffers.index;
      buffers.uvs[0] = cachedBuffers.uv;
      buffers.position = new THREE.BufferAttribute(buffers.position, 3);
      buffers.normal = new THREE.BufferAttribute(buffers.normal, 3);

      if (params.builder.uvCount > 1) {
        buffers.uvs[1] = new THREE.BufferAttribute(buffers.uvs[1], 1);
      }

      var geometry = new _TileGeometry["default"](params, buffers);
      geometry.OBB = builder.OBB(geometry.boundingBox);
      geometry._count = 0;

      geometry.dispose = function () {
        geometry._count--;

        if (geometry._count == 0) {
          THREE.BufferGeometry.prototype.dispose.call(geometry);

          _Cache["default"]["delete"](bufferKey);
        }
      };

      resolve(geometry);
      return {
        geometry: geometry,
        quaternion: quaternion,
        position: position
      };
    });
  }

  return promiseGeometry.then(function (geometry) {
    return {
      geometry: geometry,
      quaternion: quaternion,
      position: position
    };
  });
}