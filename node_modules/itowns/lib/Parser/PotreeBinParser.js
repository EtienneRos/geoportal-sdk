"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var THREE = _interopRequireWildcard(require("three"));

// See the different constants holding ordinal, name, numElements, byteSize in PointAttributes.cpp in PotreeConverter
// elementByteSize is byteSize / numElements
var POINT_ATTTRIBUTES = {
  POSITION_CARTESIAN: {
    numElements: 3,
    arrayType: Float32Array,
    attributeName: 'position'
  },
  COLOR_PACKED: {
    numElements: 4,
    arrayType: Uint8Array,
    attributeName: 'color',
    normalized: true
  },
  INTENSITY: {
    numElements: 1,
    numByte: 2,
    // using Float32Array because Float16Array doesn't exist
    arrayType: Float32Array,
    attributeName: 'intensity',
    normalized: true
  },
  CLASSIFICATION: {
    numElements: 1,
    arrayType: Uint8Array,
    attributeName: 'classification'
  },
  // Note: at the time of writing, PotreeConverter will only generate normals in Oct16 format
  // see PotreeConverter.cpp:121
  // we keep all the historical value to still supports old conversion
  NORMAL_SPHEREMAPPED: {
    numElements: 2,
    arrayType: Uint8Array,
    attributeName: 'sphereMappedNormal'
  },
  // see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602
  NORMAL_OCT16: {
    numElements: 2,
    arrayType: Uint8Array,
    attributeName: 'oct16Normal'
  },
  NORMAL: {
    numElements: 3,
    arrayType: Float32Array,
    attributeName: 'normal'
  }
};

var _loop = function () {
  var potreeName = _Object$keys[_i];
  var attr = POINT_ATTTRIBUTES[potreeName];
  attr.potreeName = potreeName;
  attr.numByte = attr.numByte || attr.arrayType.BYTES_PER_ELEMENT;
  attr.byteSize = attr.numElements * attr.numByte;
  attr.normalized = attr.normalized || false; // chrome is known to perform badly when we call a method without respecting its arity

  var fnName = "getUint".concat(attr.numByte * 8);
  attr.getValue = attr.numByte === 1 ? function (view, offset) {
    return view[fnName](offset);
  } : function (view, offset) {
    return view[fnName](offset, true);
  };
};

for (var _i = 0, _Object$keys = Object.keys(POINT_ATTTRIBUTES); _i < _Object$keys.length; _i++) {
  _loop();
}

var _default = {
  /** @module PotreeBinParser */

  /** Parse .bin PotreeConverter format and convert to a THREE.BufferGeometry
   * @function parse
   * @param {ArrayBuffer} buffer - the bin buffer.
   * @param {Object} pointAttributes - the point attributes information contained in layer.metadata coming from cloud.js
   * @return {Promise} - a promise that resolves with a THREE.BufferGeometry.
   *
   */
  parse: function (buffer, pointAttributes) {
    if (!buffer) {
      throw new Error('No array buffer provided.');
    }

    var view = new DataView(buffer); // Format: X1,Y1,Z1,R1,G1,B1,A1,[...],XN,YN,ZN,RN,GN,BN,AN

    var pointByteSize = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pointAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var potreeName = _step.value;
        pointByteSize += POINT_ATTTRIBUTES[potreeName].byteSize;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var numPoints = Math.floor(buffer.byteLength / pointByteSize);
    var geometry = new THREE.BufferGeometry();
    var elemOffset = 0;
    var attrOffset = 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = pointAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _potreeName = _step2.value;
        var attr = POINT_ATTTRIBUTES[_potreeName];
        var arrayLength = attr.numElements * numPoints;
        var array = new attr.arrayType(arrayLength);

        for (var arrayOffset = 0; arrayOffset < arrayLength; arrayOffset += attr.numElements) {
          for (var elemIdx = 0; elemIdx < attr.numElements; elemIdx++) {
            array[arrayOffset + elemIdx] = attr.getValue(view, attrOffset + elemIdx * attr.numByte);
          }

          attrOffset += pointByteSize;
        }

        elemOffset += attr.byteSize;
        attrOffset = elemOffset;
        geometry.addAttribute(attr.attributeName, new THREE.BufferAttribute(array, attr.numElements, attr.normalized));
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    geometry.computeBoundingBox();
    return Promise.resolve(geometry);
  }
};
exports["default"] = _default;