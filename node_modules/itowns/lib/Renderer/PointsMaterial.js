"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.MODE = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _three = require("three");

var _Capabilities = _interopRequireDefault(require("../Core/System/Capabilities"));

var _ShaderUtils = _interopRequireDefault(require("./Shader/ShaderUtils"));

/* babel-plugin-inline-import './Shader/PointsVS.glsl' */
var PointsVS = "#include <itowns/precision_qualifier>\n#include <itowns/project_pars_vertex>\n#if defined(USE_TEXTURES_PROJECTIVE)\n#include <itowns/projective_texturing_pars_vertex>\n#endif\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nuniform float size;\n\nuniform bool pickingMode;\nuniform int mode;\nuniform float opacity;\nuniform vec4 overlayColor;\nattribute vec3 color;\nattribute vec4 unique_id;\nattribute float intensity;\n\n#if defined(NORMAL_OCT16)\nattribute vec2 oct16Normal;\n#elif defined(NORMAL_SPHEREMAPPED)\nattribute vec2 sphereMappedNormal;\n#else\nattribute vec3 normal;\n#endif\n\nvarying vec4 vColor;\n\n// see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602\n// and implementation in PotreeConverter (BINPointReader.cpp) and potree (BinaryDecoderWorker.js)\n#if defined(NORMAL_OCT16)\nvec3 decodeOct16Normal(vec2 encodedNormal) {\n    vec2 nNorm = 2. * (encodedNormal / 255.) - 1.;\n    vec3 n;\n    n.z = 1. - abs(nNorm.x) - abs(nNorm.y);\n    if (n.z >= 0.) {\n        n.x = nNorm.x;\n        n.y = nNorm.y;\n    } else {\n        n.x = sign(nNorm.x) - sign(nNorm.x) * sign(nNorm.y) * nNorm.y;\n        n.y = sign(nNorm.y) - sign(nNorm.y) * sign(nNorm.x) * nNorm.x;\n    }\n    return normalize(n);\n}\n#elif defined(NORMAL_SPHEREMAPPED)\n// see http://aras-p.info/texts/CompactNormalStorage.html method #4\n// or see potree's implementation in BINPointReader.cpp\nvec3 decodeSphereMappedNormal(vec2 encodedNormal) {\n    vec2 fenc = 2. * encodedNormal / 255. - 1.;\n    float f = dot(fenc,fenc);\n    float g = 2. * sqrt(1. - f);\n    vec3 n;\n    n.xy = fenc * g;\n    n.z = 1. - 2. * f;\n    return n;\n}\n#endif\n\nvoid main() {\n\n#if defined(NORMAL_OCT16)\n    vec3  normal = decodeOct16Normal(oct16Normal);\n#elif defined(NORMAL_SPHEREMAPPED)\n    vec3 normal = decodeSphereMappedNormal(sphereMappedNormal);\n#elif defined(NORMAL)\n    // nothing to do\n#else\n    // default to color\n    vec3 normal = color;\n#endif\n\n    if (pickingMode) {\n        vColor = unique_id;\n    } else if (mode == MODE_INTENSITY) {\n        vColor = vec4(intensity, intensity, intensity, opacity);\n    } else if (mode == MODE_NORMAL) {\n        vColor = vec4(abs(normal), opacity);\n    } else {\n        // default to color mode\n        vColor = vec4(mix(color, overlayColor.rgb, overlayColor.a), opacity);\n    }\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    if (size > 0.) {\n        gl_PointSize = size;\n    } else {\n        gl_PointSize = clamp(-size / gl_Position.w, 3.0, 10.0);\n    }\n\n#if defined(USE_TEXTURES_PROJECTIVE)\n    #include <itowns/projective_texturing_vertex>\n#endif\n    #include <logdepthbuf_vertex>\n}\n";

/* babel-plugin-inline-import './Shader/PointsFS.glsl' */
var PointsFS = "#include <itowns/precision_qualifier>\n#include <logdepthbuf_pars_fragment>\n#if defined(USE_TEXTURES_PROJECTIVE)\n#include <itowns/projective_texturing_pars_fragment>\n#endif\n\nvarying vec4 vColor;\nuniform bool pickingMode;\nvoid main() {\n    #include <logdepthbuf_fragment>\n    // circular point rendering\n    if(length(gl_PointCoord - 0.5) > 0.5){\n        discard;\n    }\n\n#if defined(USE_TEXTURES_PROJECTIVE)\n    vec4 color = vColor;\n    if (!pickingMode) {\n        #pragma unroll_loop\n        for (int i = 0; i < ORIENTED_IMAGES_COUNT; i++) {\n            color = projectiveTextureColor(projectiveTextureCoords[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTextureDistortion[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTexture[ ORIENTED_IMAGES_COUNT - 1 - i ], mask[ORIENTED_IMAGES_COUNT - 1 - i], color);\n        }\n        gl_FragColor = vec4(color.rgb, color.a * opacity);\n    } else {\n        gl_FragColor = color;\n    }\n#else\n    gl_FragColor = vColor;\n#endif\n}\n";
var MODE = {
  COLOR: 0,
  INTENSITY: 1,
  CLASSIFICATION: 2,
  NORMAL: 3
};
exports.MODE = MODE;

var PointsMaterial =
/*#__PURE__*/
function (_RawShaderMaterial) {
  (0, _inherits2["default"])(PointsMaterial, _RawShaderMaterial);

  function PointsMaterial() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PointsMaterial);
    var oiMaterial = options.orientedImageMaterial;
    delete options.orientedImageMaterial;
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PointsMaterial).call(this, options));
    _this.vertexShader = PointsVS;
    _this.size = options.size || 0;
    _this.scale = options.scale || 0.05 * 0.5 / Math.tan(1.0 / 2.0); // autosizing scale

    _this.overlayColor = options.overlayColor || new _three.Vector4(0, 0, 0, 0);
    _this.mode = options.mode || MODE.COLOR;
    _this.picking = false;

    for (var key in MODE) {
      if (Object.prototype.hasOwnProperty.call(MODE, key)) {
        _this.defines["MODE_".concat(key)] = MODE[key];
      }
    }

    _this.uniforms.size = new _three.Uniform(_this.size);
    _this.uniforms.mode = new _three.Uniform(_this.mode);
    _this.uniforms.pickingMode = new _three.Uniform(_this.picking);
    _this.uniforms.opacity = new _three.Uniform(_this.opacity);
    _this.uniforms.overlayColor = new _three.Uniform(_this.overlayColor);

    if (oiMaterial) {
      _this.uniforms.projectiveTextureAlphaBorder = oiMaterial.uniforms.projectiveTextureAlphaBorder;
      _this.uniforms.projectiveTextureDistortion = oiMaterial.uniforms.projectiveTextureDistortion;
      _this.uniforms.projectiveTextureMatrix = oiMaterial.uniforms.projectiveTextureMatrix;
      _this.uniforms.projectiveTexture = oiMaterial.uniforms.projectiveTexture;
      _this.uniforms.mask = oiMaterial.uniforms.mask;
      _this.uniforms.boostLight = oiMaterial.uniforms.boostLight;
      _this.defines.ORIENTED_IMAGES_COUNT = oiMaterial.defines.ORIENTED_IMAGES_COUNT;
      _this.defines.USE_DISTORTION = oiMaterial.defines.USE_DISTORTION;
      _this.defines.DEBUG_ALPHA_BORDER = oiMaterial.defines.DEBUG_ALPHA_BORDER;
      _this.defines.USE_TEXTURES_PROJECTIVE = true;
      _this.defines.USE_BASE_MATERIAL = true;
      _this.fragmentShader = _ShaderUtils["default"].unrollLoops(PointsFS, _this.defines);
    } else {
      _this.fragmentShader = PointsFS;
    }

    if (_Capabilities["default"].isLogDepthBufferSupported()) {
      _this.defines.USE_LOGDEPTHBUF = 1;
      _this.defines.USE_LOGDEPTHBUF_EXT = 1;
    }

    _this.updateUniforms();

    return _this;
  }

  (0, _createClass2["default"])(PointsMaterial, [{
    key: "copy",
    value: function copy(source) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointsMaterial.prototype), "copy", this).call(this, source);

      if (source.uniforms.projectiveTextureAlphaBorder) {
        // Don't copy oriented image because, it's a link to oriented image material.
        // It needs a reference to oriented image material.
        this.uniforms.projectiveTextureAlphaBorder = source.uniforms.projectiveTextureAlphaBorder;
        this.uniforms.projectiveTextureDistortion = source.uniforms.projectiveTextureDistortion;
        this.uniforms.projectiveTextureMatrix = source.uniforms.projectiveTextureMatrix;
        this.uniforms.projectiveTexture = source.uniforms.projectiveTexture;
        this.uniforms.mask = source.uniforms.mask;
        this.uniforms.boostLight = source.uniforms.boostLight;
      }

      return this;
    }
  }, {
    key: "enablePicking",
    value: function enablePicking(picking) {
      this.picking = picking;
      this.blending = picking ? _three.NoBlending : _three.NormalBlending;
      this.updateUniforms();
    }
  }, {
    key: "updateUniforms",
    value: function updateUniforms() {
      // if size is null, switch to autosizing using the canvas height
      this.uniforms.size.value = this.size > 0 ? this.size : -this.scale * window.innerHeight;
      this.uniforms.mode.value = this.mode;
      this.uniforms.pickingMode.value = this.picking;
      this.uniforms.opacity.value = this.opacity;
      this.uniforms.overlayColor.value = this.overlayColor;
    }
  }, {
    key: "update",
    value: function update(source) {
      this.visible = source.visible;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.size = source.size;
      this.mode = source.mode;
      this.picking = source.picking;
      this.scale = source.scale;
      this.overlayColor.copy(source.overlayColor);
      this.updateUniforms();
      Object.assign(this.defines, source.defines);
      return this;
    }
  }]);
  return PointsMaterial;
}(_three.RawShaderMaterial);

var _default = PointsMaterial;
exports["default"] = _default;