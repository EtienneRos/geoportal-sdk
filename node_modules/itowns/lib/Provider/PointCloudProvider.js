"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;
exports._testing = exports["default"] = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _Fetcher = _interopRequireDefault(require("./Fetcher"));

var _PointCloudProcessing = _interopRequireDefault(require("../Process/PointCloudProcessing"));

var _PotreeBinParser = _interopRequireDefault(require("../Parser/PotreeBinParser"));

var _PotreeCinParser = _interopRequireDefault(require("../Parser/PotreeCinParser"));

var _PointsMaterial = _interopRequireWildcard(require("../Renderer/PointsMaterial"));

var _Picking = _interopRequireDefault(require("../Core/Picking"));

var _Extent = _interopRequireDefault(require("../Core/Geographic/Extent"));

// Create an A(xis)A(ligned)B(ounding)B(ox) for the child `childIndex` of one aabb.
// (PotreeConverter protocol builds implicit octree hierarchy by applying the same
// subdivision algo recursively)
function createChildAABB(aabb, childIndex) {
  // Code taken from potree
  var min = aabb.min;
  var max = aabb.max;
  var dHalfLength = new THREE.Vector3().copy(max).sub(min).multiplyScalar(0.5);
  var xHalfLength = new THREE.Vector3(dHalfLength.x, 0, 0);
  var yHalfLength = new THREE.Vector3(0, dHalfLength.y, 0);
  var zHalfLength = new THREE.Vector3(0, 0, dHalfLength.z);
  var cmin = min;
  var cmax = new THREE.Vector3().add(min).add(dHalfLength);

  if (childIndex === 1) {
    min = new THREE.Vector3().copy(cmin).add(zHalfLength);
    max = new THREE.Vector3().copy(cmax).add(zHalfLength);
  } else if (childIndex === 3) {
    min = new THREE.Vector3().copy(cmin).add(zHalfLength).add(yHalfLength);
    max = new THREE.Vector3().copy(cmax).add(zHalfLength).add(yHalfLength);
  } else if (childIndex === 0) {
    min = cmin;
    max = cmax;
  } else if (childIndex === 2) {
    min = new THREE.Vector3().copy(cmin).add(yHalfLength);
    max = new THREE.Vector3().copy(cmax).add(yHalfLength);
  } else if (childIndex === 5) {
    min = new THREE.Vector3().copy(cmin).add(zHalfLength).add(xHalfLength);
    max = new THREE.Vector3().copy(cmax).add(zHalfLength).add(xHalfLength);
  } else if (childIndex === 7) {
    min = new THREE.Vector3().copy(cmin).add(dHalfLength);
    max = new THREE.Vector3().copy(cmax).add(dHalfLength);
  } else if (childIndex === 4) {
    min = new THREE.Vector3().copy(cmin).add(xHalfLength);
    max = new THREE.Vector3().copy(cmax).add(xHalfLength);
  } else if (childIndex === 6) {
    min = new THREE.Vector3().copy(cmin).add(xHalfLength).add(yHalfLength);
    max = new THREE.Vector3().copy(cmax).add(xHalfLength).add(yHalfLength);
  }

  return new THREE.Box3(min, max);
}

function parseOctree(layer, hierarchyStepSize, root) {
  return _Fetcher["default"].arrayBuffer("".concat(root.baseurl, "/r").concat(root.name, ".hrc"), layer.fetchOptions).then(function (blob) {
    var view = new DataView(blob);
    var stack = [];
    var offset = 0;
    root.childrenBitField = view.getUint8(0);
    offset += 1;
    root.numPoints = view.getUint32(1, true);
    offset += 4;
    root.children = [];
    stack.push(root);

    while (stack.length && offset < blob.byteLength) {
      var snode = stack.shift(); // look up 8 children

      for (var i = 0; i < 8; i++) {
        // does snode have a #i child ?
        if (snode.childrenBitField & 1 << i && offset + 5 <= blob.byteLength) {
          var c = view.getUint8(offset);
          offset += 1;
          var n = view.getUint32(offset, true);
          offset += 4;

          if (n == 0) {
            n = root.numPoints;
          }

          var childname = snode.name + i;
          var bounds = createChildAABB(snode.bbox, i);
          var url = root.baseurl;

          if (childname.length % hierarchyStepSize == 0) {
            var myname = childname.substr(root.name.length);
            url = "".concat(root.baseurl, "/").concat(myname);
          }

          var item = {
            numPoints: n,
            childrenBitField: c,
            children: [],
            name: childname,
            baseurl: url,
            bbox: bounds,
            layer: layer,
            parent: snode
          };
          snode.children.push(item);
          stack.push(item);
        }
      }
    }

    return root;
  });
}

function findChildrenByName(node, name) {
  if (node.name === name) {
    return node;
  }

  var charIndex = node.name.length;

  for (var i = 0; i < node.children.length; i++) {
    if (node.children[i].name[charIndex] == name[charIndex]) {
      return findChildrenByName(node.children[i], name);
    }
  }

  throw new Error("Cannot find node with name '".concat(name, "'"));
}

var nextuuid = 1;

function addPickingAttribute(points) {
  // generate unique id for picking
  var numPoints = points.geometry.attributes.position.count;
  var ids = new Uint8Array(4 * numPoints);
  var baseId = nextuuid++;

  if (numPoints > 0xffff || baseId > 0xffff) {
    // TODO: fixme
    console.warn('Currently picking is limited to Points with less than 65535 elements and less than 65535 Points instances');
    return points;
  }

  for (var i = 0; i < numPoints; i++) {
    // todo numpoints > 16bits
    var v = baseId << 16 | i;
    ids[4 * i + 0] = (v & 0xff000000) >> 24;
    ids[4 * i + 1] = (v & 0x00ff0000) >> 16;
    ids[4 * i + 2] = (v & 0x0000ff00) >> 8;
    ids[4 * i + 3] = (v & 0x000000ff) >> 0;
  }

  points.baseId = baseId;
  points.geometry.addAttribute('unique_id', new THREE.BufferAttribute(ids, 4, true));
  return points;
}

function computeBbox(layer) {
  var bbox;

  if (layer.isFromPotreeConverter) {
    bbox = new THREE.Box3(new THREE.Vector3(layer.metadata.boundingBox.lx, layer.metadata.boundingBox.ly, layer.metadata.boundingBox.lz), new THREE.Vector3(layer.metadata.boundingBox.ux, layer.metadata.boundingBox.uy, layer.metadata.boundingBox.uz));
  } else {
    // lopocs
    var idx = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = layer.metadata[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var entry = _step.value;

        if (entry.table == layer.table) {
          break;
        }

        idx++;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    bbox = new THREE.Box3(new THREE.Vector3(layer.metadata[idx].bbox.xmin, layer.metadata[idx].bbox.ymin, layer.metadata[idx].bbox.zmin), new THREE.Vector3(layer.metadata[idx].bbox.xmax, layer.metadata[idx].bbox.ymax, layer.metadata[idx].bbox.zmax));
  }

  return bbox;
}

function parseMetadata(metadata, layer) {
  layer.metadata = metadata;
  var customBinFormat = true; // Lopocs pointcloud server can expose the same file structure as PotreeConverter output.
  // The only difference is the metadata root file (cloud.js vs infos/sources), and we can
  // check for the existence of a `scale` field.
  // (if `scale` is defined => we're fetching files from PotreeConverter)

  if (layer.metadata.scale != undefined) {
    layer.isFromPotreeConverter = true; // PotreeConverter format

    customBinFormat = layer.metadata.pointAttributes === 'CIN'; // do we have normal information

    var normal = Array.isArray(layer.metadata.pointAttributes) && layer.metadata.pointAttributes.find(function (elem) {
      return elem.startsWith('NORMAL');
    });

    if (normal) {
      layer.material.defines[normal] = 1;
    }
  } else {
    // Lopocs
    layer.metadata.scale = 1;
    layer.metadata.octreeDir = "itowns/".concat(layer.table, ".points");
    layer.metadata.hierarchyStepSize = 1000000; // ignore this with lopocs

    customBinFormat = true;
  }

  layer.parse = customBinFormat ? _PotreeCinParser["default"].parse : _PotreeBinParser["default"].parse;
  layer.extension = customBinFormat ? 'cin' : 'bin';
  layer.supportsProgressiveDisplay = customBinFormat;
}

function getObjectToUpdateForAttachedLayers(meta) {
  if (meta.obj) {
    var p = meta.parent;

    if (p && p.obj) {
      return {
        element: meta.obj,
        parent: p.obj
      };
    } else {
      return {
        element: meta.obj
      };
    }
  }
}

var _default = {
  preprocessDataLayer: function preprocessDataLayer(layer, view) {
    if (!layer.file) {
      layer.file = 'cloud.js';
    }

    if (!layer.group) {
      layer.group = new THREE.Group();
      layer.object3d.add(layer.group);
      layer.group.updateMatrixWorld();
    }

    if (!layer.bboxes) {
      layer.bboxes = new THREE.Group();
      layer.object3d.add(layer.bboxes);
      layer.bboxes.updateMatrixWorld();
      layer.bboxes.visible = false;
    } // default options


    layer.fetchOptions = layer.fetchOptions || {};
    layer.octreeDepthLimit = layer.octreeDepthLimit || -1;
    layer.pointBudget = layer.pointBudget || 2000000;
    layer.pointSize = layer.pointSize === 0 || !isNaN(layer.pointSize) ? layer.pointSize : 4;
    layer.sseThreshold = layer.sseThreshold || 2;
    layer.material = layer.material || {};
    layer.material = layer.material.isMaterial ? layer.material : new _PointsMaterial["default"](layer.material);
    layer.material.defines = layer.material.defines || {};
    layer.mode = _PointsMaterial.MODE.COLOR; // default update methods

    layer.preUpdate = _PointCloudProcessing["default"].preUpdate;
    layer.update = _PointCloudProcessing["default"].update;
    layer.postUpdate = _PointCloudProcessing["default"].postUpdate; // override the default method, since updated objects are metadata in this case

    layer.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers; // this probably needs to be moved to somewhere else

    layer.pickObjectsAt = function (view, mouse, radius) {
      return _Picking["default"].pickPointsAt(view, mouse, radius, layer);
    };

    return _Fetcher["default"].json("".concat(layer.url, "/").concat(layer.file), layer.fetchOptions).then(function (metadata) {
      parseMetadata(metadata, layer);
      var bbox = computeBbox(layer);
      return parseOctree(layer, layer.metadata.hierarchyStepSize, {
        baseurl: "".concat(layer.url, "/").concat(layer.metadata.octreeDir, "/r"),
        name: '',
        bbox: bbox
      });
    }).then(function (root) {
      layer.root = root;
      root.findChildrenByName = findChildrenByName.bind(root, root);
      layer.extent = _Extent["default"].fromBox3(view.referenceCrs, root.bbox);
      return layer;
    });
  },
  executeCommand: function executeCommand(command) {
    var layer = command.layer;
    var metadata = command.requester; // Query HRC if we don't have children metadata yet.

    if (metadata.childrenBitField && metadata.children.length === 0) {
      parseOctree(layer, layer.metadata.hierarchyStepSize, metadata).then(function () {
        return command.view.notifyChange(layer, false);
      });
    } // `isLeaf` is for lopocs and allows the pointcloud server to consider that the current
    // node is the last one, even if we could subdivide even further.
    // It's necessary because lopocs doens't know about the hierarchy (it generates it on the fly
    // when we request .hrc files)


    var url = "".concat(metadata.baseurl, "/r").concat(metadata.name, ".").concat(layer.extension, "?isleaf=").concat(command.isLeaf ? 1 : 0);
    return _Fetcher["default"].arrayBuffer(url, layer.fetchOptions).then(function (buffer) {
      return layer.parse(buffer, layer.metadata.pointAttributes);
    }).then(function (geometry) {
      var points = new THREE.Points(geometry, layer.material.clone());
      addPickingAttribute(points);
      points.frustumCulled = false;
      points.matrixAutoUpdate = false;
      points.position.copy(metadata.bbox.min);
      points.scale.set(layer.metadata.scale, layer.metadata.scale, layer.metadata.scale);
      points.updateMatrix();
      points.tightbbox = geometry.boundingBox.applyMatrix4(points.matrix);
      points.layers.set(layer.threejsLayer);
      points.layer = layer;
      points.extent = _Extent["default"].fromBox3(command.view.referenceCrs, metadata.bbox);
      points.userData.metadata = metadata;
      return points;
    });
  }
};
exports["default"] = _default;
var _testing = {
  parseMetadata: parseMetadata
};
exports._testing = _testing;